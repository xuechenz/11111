from __future__ import annotations

import json
from typing import Dict, List, Optional
from pathlib import Path
from datetime import datetime

_TERMSHEET_TEMPLATE: Dict = {
    "Accrues When": "Inside Range",
    # placeholders – will be overwritten by `build_termsheet()`
    "Autocall Barrier": [],
    "Autocall Dates": [],
    "Autocall Ex Dates": [],
    "Autocall Pay Dates": [],
    "Coupon Determination Dates": [],
    "Coupon Determination Ex Dates": [],
    "Coupon Pay Dates": [],
    "Coupon Low Barrier": [],
    "Basket Level Type": "Weighted Sum of Asset Returns",
    "Basket Weights": [1],
    "Maturity Barrier": 0.7,
    "Maturity Date": "2026-08-07",
    "Maturity Settlement Date": "2026-08-12",
    "Pay ID": "USD",
    "Return Notional At Recall": True,
    "Stock IDs": [],
    "Strike Setting Date": ["2025-07-07"],
}

_NUMERIC_DEFAULTS: Dict = {
    "Computation Type": "Monte Carlo",
    "Number of Paths": 100_000,
    "Random Sampler Type": "NormalCNDFInvSampler",
    "Random Uniform Generator": "RandomSobol",
}

def build_termsheet(
    underlying_id: str,
    autocall_dates: List[str],
    coupon_barrier: float = 0.7,
    maturity_barrier: float = 0.7,
) -> Dict:
    ts = json.loads(json.dumps(_TERMSHEET_TEMPLATE))  # deep‑copy via json

    ts["Stock IDs"] = [underlying_id]

    # Autocall schedule – keep Ex‑Date / Pay‑Date two business days later
    ts["Autocall Dates"]     = autocall_dates
    ts["Autocall Ex Dates"]  = _shift_days(autocall_dates, 3)
    ts["Autocall Pay Dates"] = _shift_days(autocall_dates, 5)

    # Re‑use same set for coupon
    ts["Coupon Determination Dates"]    = autocall_dates
    ts["Coupon Determination Ex Dates"] = _shift_days(autocall_dates, 3)
    ts["Coupon Pay Dates"]              = _shift_days(autocall_dates, 5)
    ts["Coupon Low Barrier"]            = [coupon_barrier] * len(autocall_dates)

    ts["Autocall Barrier"] = [1.0] * len(autocall_dates)  # 100 % barrier
    ts["Maturity Barrier"] = maturity_barrier

    return ts


def _shift_days(date_list: List[str], n: int) -> List[str]:
    from datetime import timedelta
    out = []
    for d in date_list:
        dt = datetime.fromisoformat(d)
        out.append((dt + timedelta(days=n)).strftime("%Y-%m-%d"))
    return out

def price_autocall(
    host: str,
    port: int,
    env: Dict[str, str],
    underlying_id: str,
    autocall_dates: List[str],
    strike_idx: int = 10,
    bump_tenor: str = "3m",
    bump_size: float = 0.0025,
    numeric_overrides: Optional[Dict] = None,
    extra_termsheet_fields: Optional[Dict] = None,
) -> Dict:


    fpf = sync(host, port, env)

    vol_handle = fpf({"get": {"what": "volatility index", "id": underlying_id}})["top"][0]
    surface    = fpf({"get": vol_handle})
    strikes    = surface["strikes"]
    strike_val = strikes[strike_idx]

    request: Dict = {
        "action": "price",
        "pricer": "Autocallable Note",
        "greeks": {
            "M2M Value": True, "Vega": True, "Gamma": True,
            "Average Lifetime": True,
        },
        "numeric_parameters": {**_NUMERIC_DEFAULTS, **(numeric_overrides or {})},
        "assumptions": {
            "Dividend Model": "Discrete Proportional",
            "Volatility Model": "Local Volatility Surface",
            "Volatility Sub Type": "Effective Strike",
        },
        "termsheet": build_termsheet(underlying_id, autocall_dates),
        "bumps": [
            {
                "Type": "Volatility Bump",
                "Bump Method": "Absolute",
                "Stock IDs": [underlying_id],
                "Strike": strike_val,
                "Tenor Bump Sizes": [[bump_size]],
                "Tenors": [bump_tenor],
            }
        ],
        "curve_mapping": {
            "Mongo Curve Mapping": {"ID": "cof_discounting_USA"}
        },
        "max_paths": 10_000,
        "with_slave": True,
        "storing_pricing_data": False,
        "rid": "single‑run",
    }

    # allow caller to tweak any field in the autogenerated termsheet
    if extra_termsheet_fields:
        request["termsheet"].update(extra_termsheet_fields)

    return fpf(request)


if __name__ == "__main__":
    ENV = {"name": "000", "password": "000"}

    result = price_autocall(
        host           = "000",
        port           = 000,
        env            = ENV,
        underlying_id  = "NDX.IDX",
        autocall_dates = ["2025-11-07", "2026-02-09", "2026-05-07", "2026-08-07"],
    )

    out = Path("outputs"); out.mkdir(exist_ok=True)
    ts  = datetime.now().strftime("%Y%m%d_%H%M%S")
    path = out / f"auto_single_raw_{ts}.json"
    json.dump(result, path.open("w"), indent=2)
    print(f"Pricer Done → {path}")
